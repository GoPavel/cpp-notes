\section{Exception safety}
\subsection{Мотивирующий пример}
Рассмотрим функцию копирования данных в векторе.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void vector<T>::operator=(vector<T> const& other) {
    data = new char(sizeof(T) * other.size());
    for (size_t i = 0; i != other.size(); ++i) {
        new (data + i) T(other[i]);
    }
}
\end{minted}

На первый взгляд это довольно безобидный код. Но он совершено не учитывает возможность возникновения исключения в одном из вызовов конструктора \mintinline{c++}{T()}. Что произойдет в этом случаи?

Исключение пролетит дальше. Предположим, что его кто-то поймал. Но тогда он обнаружит наш вектор в сломанном состоянии. И не сможет ничего с ним сделать. Любой вызов public-метода вызывает undefined behavior, так как нарушены инварианты класса.

Напишем аккуратнее.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void vector<T>::operator=(vector<T> const& other) {
    size_t i = 0;
    try {
        data = new char[sizeof(T) * other.size()];
        for (size_t i = 0; i != other.size(); ++i) {
            new (data + i) T(other[i]);
        }
    }
    catch(...) { // если ошибка при копировании
        for (size_t j = i; j != 0; --j) {
            data[j - 1].~T(); // вызовем деструкторы созданных объектов
        }
        delete[] data;
        data = nullptr;
    }
}
\end{minted}

Если исключения не возникнет то функция скопирует данные, иначе data занулится, что будет соответствовать пустому вектору. И мы сохранили инварианты, то есть класс остался в корректном состоянии и пользователь может вызывать public-методы.

Например:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
vector<int> a, b;
/*
* some code
*/
try {
    a = b
} catch(...) {
    if (a.size() == 0) {
        std::cout << "Bad copy" << std::endl;
    }
}
\end{minted}

Давайте обобщим этот пример:

Часто мы хотим, что в случае возникновения исключение в коде какой-то структуры данных инварианты класса сохранялись, чтобы пользователь мог корректно обработать вылетевшие исключения.

Это идея развилась в Гарантии безопасности исключений.

\subsection{Определение}

Гарантии безопасности исключений (\textit{англ.} Exception safety) -- это контракт для методов класса относительно исключений.

Уровни гарантий:
\begin{enumerate}
\item \textbf{<<Basic guarantees>>} -- Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
\item \textbf{<<Strong guarantees>>} -- Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
\item \textbf{<<Nothrow guarantees>>} -- Кроме базовой гарантии, гарантируется, что исключения не возникают.
\item \textbf{<<No guarantees>>} -- нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что продолжать работу программы нельзя.
 % TODO: No guarantees это не совсем гарантия, это я бы сказал её отсутствие. В корректных программах такое иметься не должно. Я бы даже его отдельно написал.
 % FIXME: Зачем про это вообще писать?
\end{enumerate}

Разберем пару примеров для вектора.
\begin{itemize}
\item \mintinline{c++}{std::swap} -- имеет гарантию \textit{Nothrow}. То есть при любых обстоятельствах нам гарантируется, что функция отработает корректно.

Также этой гарантии отвечает \mintinline{c++}{pop_back()}.

\item \mintinline{c++}{operator=} -- нелья сделать \textit{Nothrow}, так необходимо выделить память. Но мы можем сделать Strong гарантию, если скопируем данные в временный объект, а потом сделать \mintinline{c++}{swap()}, если копирование прошло успешно. Иначе временный объект удалиться и \mintinline{c++}{this} не измениться.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
vector<T>& vector<T>::operator=(vector const& other) {
    return this->swap(vector(other)); // swap trick!
}
\end{minted}
Если конструктор копирования будет отвечать хотя бы базовой гарантии, то оператор копирования можно сделать строгой гарантии.

\textcolor{red}{NB}) Этот метод, когда мы делаем операции отвечающие базовой гарантии во временном объекте, называется swap trick.

\item Конструкторы вектора не могу удовлетворить даже строгой, так как до их вызова объект еще не собран и не отвечает инвариантам класса.
\end{itemize}

\subsection{Best practice}

Методы пользовательского интерфейса должны удовлетворять хотя бы какой-то гарантии. Это избавляет пользователей от утечек памяти и инвалидных данных.

Деструктор должен отвечать строгой гарантии. То есть не пробрасывать исключения, так как он может быть вызван для очистки стека во время возникновения исключения. В этом случаи мы не может корректно очистить стек.

Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
vector<T>& vector<T>::operator=(vector const& other) {
    return this->swap(vector(other)); // swap trick!
}
\end{minted}

Мы копируем \mintinline{c++}{other} во временный объект \mintinline{c++}{vector(other)}, а потом делаем \mintinline{c++}{swap} с ним. Если произойдет исключение при копировании \mintinline{c++}{other} во временный объект, то оно пробросится к нам. \mintinline{c++}{swap()} не выполнится и исключение проброситься дальше. Наш объект не поменяется.

\textcolor{red}{NB}) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.

Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

\textcolor{red}{Offtops:}

Можно попросить оператор \mintinline{c++}{new} не кидать исключение с помощью константы \mintinline{c++}{std::nothrow}
