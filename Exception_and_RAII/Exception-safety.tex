\section{Exception safety}
\subsection{Мотивирующий пример}
Пусть у нас есть функция \mintinline{c++}{vector::resize()};

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template<typename T>
void vector<T>::resize(size_t size) {
    if (size > curr_size) {
        cnt_add = size - curr_size; // количество элементов для добавления.
        for (size_t i = 0; i < cnt_add; ++i) {
            push_back(T());
        }
    }
}
\end{minted}


Это код не использует исключения, то есть не генерирует их и не ловит. Но если будет ошибка выделения памяти при расширении вектора, то исключение возникнет в функции push\_back(), потом пробросятся через resize() наружу.

То есть проблема в том, что мы не используя механизм исключений все равно можем получить от него проблемы. Как например, не пойманное исключение.
% TODO: Все замечательно, но не сказано в чем собственно проблема. Проблема в том, что мы видимо хотим, чтобы либо объект не менялся (при исключении) либо менялся в нужное состояние (при отсутствии исключения) т.е. строгую гарантию. Но совсем не понятно почему мы это хотим. Пример с copy_construct в Exception.tex был гораздо показательнее, там просто всё в хлам ломалось.

\subsection{Определение}

Поэтому существуют Гарантии безопасности исключений (Exception safety). Это некий контракт исключений, который представляет из себя ряд уровней безопасности, которые присваиваются всем методам класса. Они декларируют выполнение некоторого контракта относительно состояния объекта после выполнения операций над ним.
% TODO: Определение сложное. Она даже наверное корректое, просто из него не совсем понятно о чем это.
% Я предлагаю дать определение на примере:
% Пусть у нас есть объект типа std::vector, и я вызываю у него функцию push_back.
% Функция push_back бросила эксепшен, что я после этого могу знать о состоянии vector'а?
% И я предлагаю перечислять начиная с самой сильной, потому, что когда читаешь про самые слабые не понятно зачем они вообще нужны. А так понятнее, что это просто ослабление сильных гарантий в тех случаях когда их предоставить не получается.

Уровни гарантий:
\begin{enumerate}
\item \textbf{<<No guarantees>>} - нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что продолжать работу программы нельзя. % TODO: No guarantees это не совсем гарантия, это я бы сказал её отсутствие. В корректных программах такое иметься не должно. Я бы даже его отдельно написал.
\item \textbf{<<Basic guarantees>>} - Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
\item \textbf{<<Strong guarantees>>} - Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
\item \textbf{<<Nothrow guarantees>>} - Кроме базовой гарантии, гарантируется, что исключения не возникают.
\end{enumerate}

\subsection{Основные моменты}

Теперь давайте рассмотрим важные моменты:
\begin{itemize}
\item Методы пользовательского интерфейса должны удовлетворять базовым или строгим гарантиям. Это избавляет пользователей от утечек памяти и инвалидных данных. % TODO: А Nothrow guarantee можно? Я бы сказал так, в корректных программах все функции должны иметь какую-то гарантию безопасности исключений либо не использовать исключения.

\item Также важно, чтобы деструктор не пробросал исключений, иначе утечки неизбежны. Например, может возникнуть исключение и при очистки стека, возникает еще одно. % TODO: непонятно

\item Важность гарантии nothrow:
Она есть у очень небольшого количества функции: swap, vector::pop\_back, операции с итераторами, Это гарантия очень важна, так как с ее помощью достигается строгая гарантия, когда мы производим необходимы операции на временном объекте, а потом просто делаем с ним swap.
\end{itemize}

\subsection{Best practice}

Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
vector<T>& vector<T>::operator=(vector const& other) {
    return this->swap(vector(other)); // swap trick!
}
\end{minted}

Мы копируем other во временный объект vector(other), а потом делаем swap с ним. Если произойдет исключение при копировании other во временный объект, то оно пробросится к нам. swap() не выполнится и исключение проброситься дальше. Наш объект не поменяется.

\textcolor{red}{NB}) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.

Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

\textcolor{red}{Offtops:}

Можно попросить оператор \mintinline{c++}{new} не кидать исключение с помощью константы \mintinline{c++}{std::nothrow}
