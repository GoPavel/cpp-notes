\section{Зачем nullptr? Ведь в C он был не нужен.}
В C++ 0 используется и как число 0 и как нулевой указатель. 
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int i = 0;
void* p = 0; // OK
\end{minted}
При этом 0 имеет тип {\bf int}.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T arg);

f(0); // calls f<int>(0)
\end{minted}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void g(int);
void g(void*);

f(0); // calls g(int)
\end{minted}

Даже макрос \textcolor{magenta}{NULL} определен как {\bf \#define \textcolor{magenta}{NULL} 0}.
Несмотря на это, приведения {\bf int} в указатель нет:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int i = 0;
void* p = i; // error: invalid conversion from 'int' to 'void*'
\end{minted}
Дело в том, что хотя 0 и имеет тип int, есть специальное правило, что rvalue интегрального типа с compile-time значением 0 приводимо в указатель. Получившийся указатель будет нулевым указателем. Следствием этого правила является то, что любое compile-time выражение вычисляемое в 0 можно ипользовать для получения нулевого указателя:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void* p = 2 - 2; // OK в C++03
void* p = 2 + 2; // error: invalid conversion from 'int' to 'void*'
\end{minted}
В С++11 это правило покрутили и теперь только целочесленный литерал может использоваться в качестве нулевого указателя.

До появления в языке шаблонов, два разных применения 0 не создавали проблем. Но с появлением шаблонов возникла следующая проблема при форвандинге. Предположим мы хотим, чтобы {\bf f} форвардил аргумент в {\bf g}.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T const& arg)
{
    g(arg);
}
\end{minted}
При такой перегрузке, если есть перегрузка {\bf g(int)}, {\bf f} можно вызвать от {\bf int}. Если есть перегрузка {\bf g(std::string)}, {\bf f} можно вызвать от {\bf std::string}. Но если есть перегрузка {\bf g(void*)}, {\bf f(0)} вызвать нельзя. Дело в том, что поскольку 0 имеет тип {\bf int}, будет вызвана {\bf f<int>(0)} и {\bf arg} внутри {\bf f} не является compile-time константой, следовательно он не может быть преоразован в {\bf void*} принимаемый {\bf g}.

В C++11 появился специальный литерал называемый {\bf nullptr}. Он имеет тип {\bf std::nullptr\_t} и может быть неявно преобразован в любой указатель. При вызове {\bf f(nullptr)}, {\bf T} будет выведен в {\bf std::nullptr\_t} и внутри {\bf g} {\bf arg} будет преобразован в {\bf void*}.
